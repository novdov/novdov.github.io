---
title: '[스파크] 00. 맵리듀스와 하둡'
description: 스파크 공부를 시작하며 그 기본이 되는 개념인 하둡과 맵리듀스에 대해 간단하게 알아봅니다.
categories:
- Data Engineering
tags:
- data engineering
---

> 스파크2 프로그래밍 (위키북스, 백성민)
>
> 맵리듀스 디자인 패턴 (한빛미디어, 도널드 마이너/아담 슈크)



## 하둡/맵리듀스

### 하둡

하둡은 2003년 지금의 HDFS (Hadoop File System) 의 기초가 된 논문 [The Google File System](https://static.googleusercontent.com/media/research.google.com/ko//archive/gfs-sosp2003.pdf), 2004년 맵리듀스 관련 논문 [MapReduce: Simplified Data Processing on Large Clusters](https://static.googleusercontent.com/media/research.google.com/ko//archive/mapreduce-osdi04.pdf) 발표 이후에 더그 커팅이 맵리듀스 논문을 구현하면서 시작되었습니다. 이후 2006년 아파치 최상위 프로젝트로 승격되었고, 2009년 0.20.1 버전이 발표되었습니다.

하둡은 분산 환경의 병렬처리 프레임워크로서 크게는 **분산 파일시스템인 HDFS**와 데이터 처리를 위한 **맵리듀스 프레임워크**로 구성되어 있습니다. 하둡은 여러 대의 서버를 이용해 하나의 클러스터를 구성하며, 이렇게 클러스터로 묶인 서버의 자원을 하나의 서버처럼 사용할 수 있는 클러스터 컴퓨팅 환경을 제공합니다. 기본적으로는 분석할 데이터를 HDFS에 저장하고 HDFS 상에서 맵리듀스를 이용해 데이터를 처리하는 방식입니다.

HDFS는 하나의 네임노드와 여러 개의 데이터 노드로 구성되는고 하나의 네임노드가 나머지 데이터 노드를 관리합니다. 맵리듀스 프레임워크는 데이터를 여러 개의 맵 프로세스와 리듀서 프로세스로 나눠서 처리하는 방식입니다. 맵 프로세스는 여러 데이터 노드에 분산 저장된 데이터를 각 서버에서 병렬로 나누어 처리하고 리듀서는 이러한 맵 프로세스들의 결과를 조합해 최종 결과를 만들어 냅니다.



### 맵리듀스

HDFS에 분산 저장된 파일은 맵리듀스 잡의 입력으로 들어가는데 이 때 이 파일은 입력 포맷에 의해 분할됩니다. 하나의 파일이 입력 스플릿으로 어떻게 분리될지는 이 입력 포맷에 정의되어 있습니다. (입력 스플릿은 맵 태스크에 적재된 파일의 청크에 해당합니다.)

하둡에서 각 맵 태스크는 레코드 리더<sup>record reader</sup>, 매퍼<sup>mapper</sup>, 콤바이너<sup>combiner</sup>, 파티셔너<sup>partitioner</sup> 의 단계로 구분됩니다. 중간 키/값에 해당하는 맵 태스크의 출력<sup>output</sup> 은 리듀서로 전송됩니다. 리듀스 태스크는 셔플<sup>suffle</sup>, 정렬<sup>sort</sup>, 리듀서, 출력 포맷<sup>output format</sup> 으로 구분됩니다.



#### 레코드 리더

레코드 리더는 입력 포맷에 의해 생성된 입력 스플릿을 레코드<sup>record</sup> 로 변환 (데이터를 레코드로 파싱) 합니다. 다만 레코드 자체를 파싱하지는 않고 데이터를 키/값 쌍의 형태로 매퍼에 전달합니다. 보통 키는 위치 정보에 해당하고 값은 하나의 레코드를 구성하는 데이터 덩어리에 해당합니다.



#### 맵

매퍼에서는 레코드 리더가 전달한 각 키/값 쌍을 처리한 뒤 중간 쌍에 해당하는 0개 이상의 새로운 키/값 쌍을 만듭니다. 여기서 키/값을 무엇으로 결정하는지가 맵리듀스 잡의 결과에 매우 중요한 영향을 끼칩니다. 키는 데이터가 어떤 그룹으로 분류되는지를 나타내고, 값은 리듀서에 전달할 분석 정보에 해당합니다.



#### 콤바이너

선택적 로컬 리듀서인 콤바이너는 맵 단계에서 데이터를 분류할 수 있습니다. 콤바이너는 중간 키를 가지고 한 매퍼의 값을 모으는 메서드에 적용됩니다.



#### 파티셔너

파티셔너는 매퍼에서 받은 중간 키/값 쌍을 리듀서에 분배합니다. 파티셔너는 키의 md5sum (128비트 암호화 해시 함수) 해시 코드값을 구하고, 리듀서의 개수로 나머지 연산을 수행합니다. (`key.hashCode() % (리듀서의 개수)`) 파티셔너는 무작위로 리듀서에 키스페이스<sup>keyspace</sup> 를 배포하지만 다른 매퍼의 동일한 값을 가진 키들이 같은 리듀서에 도달하는 것을 보장합니다.



#### 셔플과 정렬

리듀스 태스크는 셔플과 정렬 단계로 시작합니다. 이 단계에서 모든 파티셔너가 생성한 출력 파일을 리듀서가 작동 중인 서버로 내려받습니다. 내려받은 개별 데이터 조각들은 키를 이용해 하나의 더 큰 데이터 목록으로 정렬됩니다. 정렬은 값을 같은 키로 묶어 리듀스 태스크에서 값을 쉽게 반복 처리하기 위함입니다.



#### 리듀스

리듀서는 분류된 데이터를 입력으로 받고 키 그룹마다 한 번씩 리듀스 함수를 실행합니다 . 함수는 키와 해당 키에 관련된 반복된 모든 값을 넘겨받습니다. 데이터 처리의 많은 부분이 이 함수에서 이루어집니다.



#### 출력 포맷

출력 포맷은 리듀스 함수의 최종 키/값 쌍을 변환하고 레코드 라이터<sup>record writer</sup> 를 이용해 파일로 출력합니다. 기본적인 출력 포맷은 키와 값을 탭으로 분리하고 줄바꿈 문자로 레코드를 분리합니다.